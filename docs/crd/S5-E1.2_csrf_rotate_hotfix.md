# S5-E1.2_csrf_rotate_hotfix — Code Review Doc

## Summary

- **Issue**: GET /api/auth/csrf returns 500 "CSRF token rotation failed" blocking token refresh workflows
- **Root cause**: Current implementation always generates new token but fails during session handling
- **Fix**: Implement mint-or-return logic - return existing token if present, mint new if missing
- **Risk**: Minimal - isolated change to single endpoint, no impact on working login mint or validation

## Files Touched

- `csrf_protection.py` - Update GET /api/auth/csrf handler with mint-or-return logic

## Proposed Changes

### Mint-or-Return Logic for GET /api/auth/csrf (≤40 LOC)

**File: `csrf_protection.py`**

```diff
    @app.route('/api/auth/csrf', methods=['GET'])
    def get_csrf_token():
        """Endpoint to fetch/rotate CSRF token (session-based auth only)"""
        logger = app.logger
        
        try:
            # Validate authentication using session-based auth
            user, error_code = validate_auth_session()
            if not user:
                response = jsonify({
                    'ok': False,
                    'error': 'Authentication required',
                    'code': error_code or 'AUTH_REQUIRED'
                })
                response.headers['Cache-Control'] = 'no-store'
                return response, 401
            
-           # Generate new CSRF token
-           csrf_token = generate_csrf_token()
+           # Mint-or-return logic: use existing token if present, mint if missing
+           session_id = session.get('session_id')
+           csrf_token = None
+           
+           if session_id:
+               session_data = session_store.get_session(session_id)
+               if session_data and session_data.get('csrf'):
+                   # Return existing token
+                   csrf_token = session_data['csrf']
+           
+           if not csrf_token:
+               # Mint new token if missing
+               csrf_token = generate_csrf_token()
+               
+               # Store in session
+               if session_id:
+                   session_data = session_store.get_session(session_id)
+                   if session_data:
+                       session_data['csrf'] = csrf_token
+                       session_store.update_session(session_id, session_data)
            
-           # Store in session
-           session_id = session.get('session_id')
-           if session_id:
-               session_data = session_store.get_session(session_id)
-               if session_data:
-                   session_data['csrf'] = csrf_token
-                   # Update session with new CSRF token
-                   session_store.update_session(session_id, session_data)
-           
            # Create response with new token
            response_data = {
                'ok': True,
                'csrf_token': csrf_token
            }
            
            response = make_response(jsonify(response_data))
            response.headers['Content-Type'] = 'application/json; charset=utf-8'
            response.headers['Cache-Control'] = 'no-store'
            response.headers['Vary'] = 'Origin'
            
            # Set new CSRF cookie with proper max_age
            set_csrf_cookie(response, csrf_token, max_age=1800)
            
            return response, 200
            
        except Exception as e:
            logger.info("csrf_issue stage=rotate reason=internal_error")
            response = jsonify({
                'ok': False,
                'error': 'CSRF token rotation failed',
                'code': 'INTERNAL_ERROR'
            })
            response.headers['Cache-Control'] = 'no-store'
            return response, 500
```

## Contracts & Names

### CSRF Contract (Unchanged)

| Component | Specification |
|-----------|---------------|
| **Cookie** | `glow_csrf` (HttpOnly=false, SameSite=Lax, Secure=true on HTTPS, Path=/, Domain=.glowme.io or host-only on mismatch) |
| **Header** | `X-CSRF-Token` (must equal glow_csrf cookie value for double-submit validation) |
| **Endpoint** | `GET /api/auth/csrf` (requires auth, returns {"csrf_token": "..."}, 401 when unauthenticated) |

### Cookie Attributes (Via set_csrf_cookie)
- **CSRF cookie**: HttpOnly=false (JS-readable), domain fallback when .glowme.io ≠ request.host
- **Session cookie**: HttpOnly=true (unchanged), configured domain maintained

### Response Headers
- **Cache-Control: no-store** on all code paths (200, 401, 500)
- **Content-Type: application/json; charset=utf-8**

## Risk & Rollback

- **Risk**: Very low - isolated change to single endpoint
- **Scope**: Only GET /api/auth/csrf endpoint affected
- **Rollback**: Single-commit revert (`git revert <sha>`)
- **No impact**: Login mint and writer validation remain unchanged

## CLI Test Plan

```bash
# 1. Login and capture cookies
curl -i -c cookies.txt -X POST "https://glowme.io/api/auth/login" \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@glow.app","password":"admin123"}'
# Expected: 200 {"ok":true} + Set-Cookie: glow_csrf=...

# 2. Get CSRF token (should work now)
curl -i -b cookies.txt -c cookies.txt "https://glowme.io/api/auth/csrf"
# Expected: 200 {"csrf_token":"..."} + Set-Cookie: glow_csrf=... + Cache-Control: no-store

# 3. Use token for birth-data POST (happy path)
CSRF_TOKEN=$(curl -s -b cookies.txt "https://glowme.io/api/auth/csrf" | grep -o '"csrf_token":"[^"]*"' | cut -d'"' -f4)
curl -i -b cookies.txt -H "X-CSRF-Token: $CSRF_TOKEN" \
  -H "Content-Type: application/json" \
  -X POST "https://glowme.io/api/birth-data" \
  -d '{"birth_time":"21:17","birth_date":"1990-05-15","timezone":""}'
# Expected: 200 (G1a normalizer processes empty timezone)

# 4. Confirm save via /api/auth/me
curl -i -b cookies.txt "https://glowme.io/api/auth/me"
# Expected: 200 with updated birth_data

# 5. Negative - unauthenticated CSRF request
curl -i "https://glowme.io/api/auth/csrf"
# Expected: 401 + Cache-Control: no-store

# 6. Negative - missing CSRF header on writer
curl -i -b cookies.txt -H "Content-Type: application/json" \
  -X POST "https://glowme.io/api/birth-data" \
  -d '{"birth_time":"21:17"}'
# Expected: 403 {"code":"CSRF_MISSING"}

# 7. Negative - mismatched CSRF header
curl -i -b cookies.txt -H "X-CSRF-Token: WRONG" \
  -H "Content-Type: application/json" \
  -X POST "https://glowme.io/api/birth-data" \
  -d '{"birth_time":"21:17"}'
# Expected: 403 {"code":"CSRF_INVALID"}
```

**Expected logs**:
- Happy path: No `csrf_issue` entries
- Negatives: `csrf_issue stage=verify reason=missing|mismatch` (from validation, not rotation)
- Internal errors only: `csrf_issue stage=rotate reason=internal_error` (keys-only)

## Implementation Notes

- **Idempotent**: Multiple calls return same token until session expires or new login
- **Backward compatible**: Existing CSRF validation logic unchanged
- **Domain fallback**: Uses existing `set_csrf_cookie()` function with domain fallback
- **Error handling**: Graceful degradation with proper HTTP status codes
- **Platform agnostic**: No absolute URLs or platform references in code

